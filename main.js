/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SaveImagesOfflinePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  autoDownloadImages: true,
  downloadOnPaste: true,
  imageFolder: "attachments",
  useMD5ForFilenames: true,
  convertPngToJpeg: false,
  jpegQuality: 85,
  maxDownloadRetries: 3,
  downloadTimeout: 3e4,
  ignoredDomains: ""
};
var SaveImagesOfflineSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Save Images Offline Settings" });
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Auto-download images").setDesc("Automatically download images when a note is opened or modified").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoDownloadImages).onChange(async (value) => {
      this.plugin.settings.autoDownloadImages = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Download on paste").setDesc("Automatically download images when pasting content with image URLs").addToggle((toggle) => toggle.setValue(this.plugin.settings.downloadOnPaste).onChange(async (value) => {
      this.plugin.settings.downloadOnPaste = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Image Storage Settings" });
    new import_obsidian.Setting(containerEl).setName("Image folder").setDesc("Folder path where images will be saved (relative to vault root)").addText((text) => text.setPlaceholder("attachments").setValue(this.plugin.settings.imageFolder).onChange(async (value) => {
      this.plugin.settings.imageFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Use MD5 for filenames").setDesc("Use MD5 hash of image content as filename (prevents duplicates)").addToggle((toggle) => toggle.setValue(this.plugin.settings.useMD5ForFilenames).onChange(async (value) => {
      this.plugin.settings.useMD5ForFilenames = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Image Processing Settings" });
    new import_obsidian.Setting(containerEl).setName("Convert PNG to JPEG").setDesc("Convert PNG images to JPEG to save space").addToggle((toggle) => toggle.setValue(this.plugin.settings.convertPngToJpeg).onChange(async (value) => {
      this.plugin.settings.convertPngToJpeg = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("JPEG Quality").setDesc("Quality of JPEG images when converting from PNG (1-100)").addSlider((slider) => slider.setLimits(1, 100, 1).setValue(this.plugin.settings.jpegQuality).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.jpegQuality = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Advanced Settings" });
    new import_obsidian.Setting(containerEl).setName("Max download retries").setDesc("Maximum number of retries when downloading an image fails").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.maxDownloadRetries).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxDownloadRetries = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Download timeout (ms)").setDesc("Timeout for image downloads in milliseconds").addText((text) => text.setValue(String(this.plugin.settings.downloadTimeout)).onChange(async (value) => {
      const timeout = Number(value);
      if (!isNaN(timeout) && timeout > 0) {
        this.plugin.settings.downloadTimeout = timeout;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Ignored domains").setDesc("Comma-separated list of domains to ignore when downloading images").addTextArea((text) => text.setPlaceholder("example.com, another-domain.com").setValue(this.plugin.settings.ignoredDomains).onChange(async (value) => {
      this.plugin.settings.ignoredDomains = value;
      await this.plugin.saveSettings();
    }));
  }
};

// imageProcessor.ts
var path = __toESM(require("path"));

// utils.ts
var import_obsidian2 = require("obsidian");
var import_crypto = require("crypto");
var IMAGE_URL_REGEX = /!\[(.*?)\]\((https?:\/\/[^\s\)]+)\)/g;
var HTML_IMG_REGEX = /<img.*?src=["'](https?:\/\/[^\s"']+)["'].*?>/g;
function isLikelyImageUrl(url) {
  console.log(`Checking if URL is likely an image: ${url}`);
  const imageExtPattern = /\.(png|jpg|jpeg|gif|webp|svg|awebp|bmp|tiff|avif)(\?|$|&|#)/i;
  const typeParamPattern = /[?&]type=(png|jpg|jpeg|gif|webp|svg|awebp|bmp|tiff|avif)/i;
  const formatParamPattern = /[?&]format=(png|jpg|jpeg|gif|webp|svg|awebp|bmp|tiff|avif)/i;
  const formatInParamPattern = /[?&;](cf|fmt|format|type)=(webp|png|jpg|jpeg|gif|avif)/i;
  const imagePathPattern = /\/(images?|photos?|pictures?|media|api\/res|creatr-uploaded-images)\/[\w\-\.]+/i;
  const datePathPattern = /\/(\d{4}(\/|-)\d{1,2}(\/|-)\d{1,2}|\d{6,14})\//i;
  const hasNestedUrl = url.includes("http") && (/[?&](url|src|image)=https?%3A/i.test(url) || url.includes("/https://") || url.includes("/http://") || // Pattern for URLs with encoded URLs or complex structures
  /https?:\/\/[^/]+\/[^/]+\/[^/]+\/[^/]+\/--.+\/https?:\/\//i.test(url) || // Pattern for URLs with base64 or other encoded content
  /[?&](token|id|data)=[A-Za-z0-9+/=_-]{20,}/i.test(url));
  const nestedImagePattern = /\.(png|jpg|jpeg|gif|webp|svg|awebp|bmp|tiff|avif)/i;
  const imageHostingPattern = /\/(api\/res|images?|photos?|pictures?|media|uploads?|content|assets|files?|static)\/[\w\-\.]+/i.test(url);
  const resourceIdPattern = /\/(res|cdn|img|image|photo|media)\/[\d\.]+\//i.test(url);
  const imageIdPattern = /[\w\-]{8,}\-[\w\-]{8,}/i;
  const result = imageExtPattern.test(url) || typeParamPattern.test(url) || formatParamPattern.test(url) || formatInParamPattern.test(url) || imageHostingPattern || resourceIdPattern || hasNestedUrl && nestedImagePattern.test(url) || // Check for URLs with image-related paths and numeric IDs (common in image servers)
  imagePathPattern.test(url) && (/\/\d+(\/$|$)/.test(url) || imageIdPattern.test(url)) || // Check for URLs with date patterns (common in news/blog image URLs)
  datePathPattern.test(url) && /\.(\w{3,4})$/.test(url);
  console.log(`URL ${url} is ${result ? "likely" : "not likely"} an image`);
  return result;
}
async function downloadImage(url, timeout = 3e4, retries = 3) {
  let attempts = 0;
  console.log(`Attempting to download image from URL: ${url}`);
  while (attempts < retries) {
    try {
      console.log(`Download attempt ${attempts + 1} for URL: ${url}`);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => {
        console.log(`Download timeout for URL: ${url}`);
        controller.abort();
      }, timeout);
      const response = await fetch(url, {
        signal: controller.signal,
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
          "Accept": "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
          "Referer": new URL(url).origin
        }
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      console.log(`Successfully downloaded image from URL: ${url}`);
      return await response.arrayBuffer();
    } catch (error) {
      attempts++;
      console.log(`Attempt ${attempts} failed for URL: ${url}. Error: ${error.message}`);
      if (attempts >= retries) {
        console.error(`Failed to download image from ${url} after ${retries} attempts:`, error);
        return null;
      }
      await new Promise((resolve) => setTimeout(resolve, 1e3));
    }
  }
  return null;
}
async function convertPngToJpeg(buffer, quality = 85) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const blob = new Blob([buffer], { type: "image/png" });
    const url = URL.createObjectURL(blob);
    img.onload = () => {
      URL.revokeObjectURL(url);
      const canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        reject(new Error("Failed to get canvas context"));
        return;
      }
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      canvas.toBlob(
        (blob2) => {
          if (!blob2) {
            reject(new Error("Failed to convert PNG to JPEG"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            if (reader.result instanceof ArrayBuffer) {
              resolve(reader.result);
            } else {
              reject(new Error("Failed to read converted JPEG"));
            }
          };
          reader.onerror = () => reject(reader.error);
          reader.readAsArrayBuffer(blob2);
        },
        "image/jpeg",
        quality / 100
      );
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error("Failed to load PNG image for conversion"));
    };
    img.src = url;
  });
}
function calculateMD5(buffer) {
  return (0, import_crypto.createHash)("md5").update(Buffer.from(buffer)).digest("hex");
}
function sanitizeFilename(filename) {
  return filename.replace(/[\\/:*?"<>|]/g, "_");
}
function getFileExtension(url) {
  console.log(`Getting file extension for URL: ${url}`);
  let extension = "";
  const pathMatch = url.match(/\/([^\/?#]+)[^\/?#]*$/);
  if (pathMatch) {
    const lastSegment = pathMatch[1];
    const extMatch = lastSegment.match(/\.([a-zA-Z0-9]+)$/i);
    if (extMatch) {
      extension = extMatch[1].toLowerCase();
      console.log(`Extracted extension ${extension} from path: ${lastSegment}`);
    }
  }
  if (!extension) {
    const typeMatch = url.match(/[?&]type=([a-zA-Z0-9]+)/i);
    if (typeMatch) {
      extension = typeMatch[1].toLowerCase();
      console.log(`Extracted extension ${extension} from type parameter`);
    }
    if (!extension) {
      const formatMatch = url.match(/[?&]format=([a-zA-Z0-9]+)/i);
      if (formatMatch) {
        extension = formatMatch[1].toLowerCase();
        console.log(`Extracted extension ${extension} from format parameter`);
      }
    }
  }
  if (!extension) {
    const fullUrlMatch = url.match(/\.([a-zA-Z0-9]+)(?:[\?#].*)?$/i);
    if (fullUrlMatch) {
      extension = fullUrlMatch[1].toLowerCase();
      console.log(`Extracted extension ${extension} from full URL`);
    }
  }
  if (!extension) {
    const nestedUrlPatterns = [
      /[?&](url|src|image)=(https?%3A[^&]+)/i,
      // Standard URL encoding
      /[?&](url|src|image)=([^&]+)/i,
      // Any parameter that might contain a URL
      /\/(https?%3A%2F%2F[^&\/?#]+)/i,
      // Path-based encoded URL
      /\/(https?:\/\/[^&\/?#]+)/i
      // Path-based raw URL
    ];
    for (const pattern of nestedUrlPatterns) {
      const nestedUrlMatch = url.match(pattern);
      if (nestedUrlMatch) {
        try {
          let decodedUrl = nestedUrlMatch[2] || nestedUrlMatch[1];
          if (decodedUrl.includes("%")) {
            try {
              decodedUrl = decodeURIComponent(decodedUrl);
            } catch (e) {
              console.log(`Failed to decode URL: ${decodedUrl}, using as is`);
            }
          }
          console.log(`Found nested URL: ${decodedUrl}`);
          const nestedExtMatch = decodedUrl.match(/\.([a-zA-Z0-9]+)(?:[\?#].*)?$/i);
          if (nestedExtMatch) {
            extension = nestedExtMatch[1].toLowerCase();
            console.log(`Extracted extension ${extension} from nested URL`);
            break;
          }
          if (decodedUrl.includes("?")) {
            const nestedQueryMatch = decodedUrl.match(/[?&](type|format)=([a-zA-Z0-9]+)/i);
            if (nestedQueryMatch) {
              extension = nestedQueryMatch[2].toLowerCase();
              console.log(`Extracted extension ${extension} from nested URL query parameter`);
              break;
            }
          }
        } catch (error) {
          console.error(`Error processing nested URL: ${error}`);
        }
      }
    }
  }
  if (!extension) {
    const formatMatch = /[?&;](cf|fmt|format|type)=(webp|png|jpg|jpeg|gif|avif)/i.exec(url);
    if (formatMatch && formatMatch[2]) {
      extension = formatMatch[2].toLowerCase();
      console.log(`Detected format parameter ${formatMatch[1]}=${formatMatch[2]}, using ${extension} extension`);
    }
  }
  if (!extension) {
    const complexUrlMatch = url.match(/\/(\w+\.(png|jpg|jpeg|gif|webp|svg|awebp|bmp|tiff|avif))[\/\?#&]/i);
    if (complexUrlMatch && complexUrlMatch[2]) {
      extension = complexUrlMatch[2].toLowerCase();
      console.log(`Extracted extension ${extension} from complex URL path component`);
    }
  }
  if (!extension) {
    console.log(`No extension found in URL: ${url}, defaulting to jpg`);
    extension = "jpg";
  }
  if (extension === "awebp") {
    console.log(`Converting awebp extension to jpg for better compatibility`);
    extension = "jpg";
  } else if (extension === "webp") {
    console.log(`Converting webp extension to jpg for better compatibility`);
    extension = "jpg";
  }
  return extension;
}
async function ensureFolderExists(vault, folderPath) {
  const folders = folderPath.split("/").filter((p) => p.length > 0);
  let currentPath = "";
  for (const folder of folders) {
    currentPath = currentPath ? `${currentPath}/${folder}` : folder;
    if (!await vault.adapter.exists(currentPath)) {
      await vault.createFolder(currentPath);
    }
  }
}
function showNotice(message, duration = 3e3) {
  new import_obsidian2.Notice(message, duration);
}
function isIgnoredDomain(url, ignoredDomains) {
  if (!ignoredDomains)
    return false;
  try {
    const urlObj = new URL(url);
    const domain = urlObj.hostname;
    const ignoredList = ignoredDomains.split(",").map((d) => d.trim().toLowerCase());
    return ignoredList.some(
      (ignoredDomain) => domain === ignoredDomain || domain.endsWith(`.${ignoredDomain}`)
    );
  } catch (error) {
    console.error("Error parsing URL:", error);
    return false;
  }
}

// imageProcessor.ts
async function processMarkdownFile(file, vault, settings) {
  const content = await vault.read(file);
  const stats = {
    total: 0,
    downloaded: 0,
    failed: 0,
    skipped: 0
  };
  const newContent = await processContent(content, file, vault, settings, stats);
  return { content: newContent, stats };
}
async function processContent(content, file, vault, settings, stats) {
  const imageFolder = settings.imageFolder;
  await ensureFolderExists(vault, imageFolder);
  let newContent = await replaceAsync(content, IMAGE_URL_REGEX, async (match, altText, imageUrl) => {
    if (!isLikelyImageUrl(imageUrl)) {
      console.log(`Skipping URL that doesn't appear to be an image: ${imageUrl}`);
      return match;
    }
    stats.total++;
    if (isIgnoredDomain(imageUrl, settings.ignoredDomains)) {
      stats.skipped++;
      return match;
    }
    console.log(`Processing image URL: ${imageUrl}`);
    const result = await downloadAndSaveImage(imageUrl, vault, settings);
    if (result.success) {
      stats.downloaded++;
      return `![${altText}](${result.localPath})`;
    } else {
      stats.failed++;
      console.error(`Failed to download image: ${imageUrl}`, result.error);
      return match;
    }
  });
  newContent = await replaceAsync(newContent, HTML_IMG_REGEX, async (match, imageUrl) => {
    if (!isLikelyImageUrl(imageUrl)) {
      console.log(`Skipping HTML URL that doesn't appear to be an image: ${imageUrl}`);
      return match;
    }
    stats.total++;
    if (isIgnoredDomain(imageUrl, settings.ignoredDomains)) {
      stats.skipped++;
      return match;
    }
    console.log(`Processing HTML image URL: ${imageUrl}`);
    const result = await downloadAndSaveImage(imageUrl, vault, settings);
    if (result.success) {
      stats.downloaded++;
      const altMatch = match.match(/alt=["']([^"']*)["']/);
      const altText = altMatch ? altMatch[1] : "";
      return `![${altText}](${result.localPath})`;
    } else {
      stats.failed++;
      console.error(`Failed to download image: ${imageUrl}`, result.error);
      return match;
    }
  });
  return newContent;
}
async function downloadAndSaveImage(imageUrl, vault, settings) {
  console.log(`Starting download and save process for image URL: ${imageUrl}`);
  try {
    const imageData = await downloadImage(
      imageUrl,
      settings.downloadTimeout,
      settings.maxDownloadRetries
    );
    if (!imageData) {
      return {
        success: false,
        error: new Error(`Failed to download image from ${imageUrl}`)
      };
    }
    let finalImageData = imageData;
    let fileExtension = getFileExtension(imageUrl);
    const header = new Uint8Array(imageData.slice(0, 12));
    let detectedExtension = "";
    if (header[0] === 137 && header[1] === 80 && header[2] === 78 && header[3] === 71) {
      detectedExtension = "png";
      console.log(`Detected PNG signature in binary data`);
    } else if (header[0] === 255 && header[1] === 216) {
      detectedExtension = "jpg";
      console.log(`Detected JPEG signature in binary data`);
    } else if (header[0] === 71 && header[1] === 73 && header[2] === 70) {
      detectedExtension = "gif";
      console.log(`Detected GIF signature in binary data`);
    } else if (header[0] === 82 && header[1] === 73 && header[2] === 70 && header[3] === 70) {
      if (header[8] === 87 && header[9] === 69 && header[10] === 66 && header[11] === 80) {
        detectedExtension = "jpg";
        console.log(`Detected WEBP signature in binary data, using jpg for compatibility`);
      } else {
        detectedExtension = "jpg";
        console.log(`Detected RIFF signature but not WEBP in binary data, using jpg`);
      }
    } else if (header[0] === 66 && header[1] === 77) {
      detectedExtension = "bmp";
      console.log(`Detected BMP signature in binary data`);
    }
    if (detectedExtension && detectedExtension !== fileExtension) {
      console.log(`Extension mismatch: URL suggests ${fileExtension} but binary data indicates ${detectedExtension}`);
      fileExtension = detectedExtension;
    }
    if (!fileExtension) {
      fileExtension = "jpg";
      console.log(`Could not detect file type for ${imageUrl}, defaulting to jpg`);
    }
    if (fileExtension === "awebp") {
      console.log(`Converting awebp extension to jpg for better compatibility`);
      fileExtension = "jpg";
    }
    if (settings.convertPngToJpeg && fileExtension.toLowerCase() === "png") {
      try {
        finalImageData = await convertPngToJpeg(imageData, settings.jpegQuality);
        fileExtension = "jpg";
      } catch (error) {
        console.error("Error converting PNG to JPEG:", error);
      }
    }
    let filename;
    if (settings.useMD5ForFilenames) {
      const hash = calculateMD5(finalImageData);
      let meaningfulName = "";
      try {
        const urlObj = new URL(imageUrl);
        const urlPath = urlObj.pathname;
        const pathSegments = urlPath.split("/").filter((segment) => segment.length > 0);
        if (pathSegments.length > 0) {
          for (let i = pathSegments.length - 1; i >= 0; i--) {
            const segment = pathSegments[i];
            if (!/^[0-9a-f]{8,}$/i.test(segment) && !/^\d+$/.test(segment)) {
              meaningfulName = segment.replace(/\.[^.]+$/, "");
              break;
            }
          }
        }
        if (!meaningfulName) {
          const hostname = urlObj.hostname.replace(/\./g, "-");
          meaningfulName = hostname;
        }
      } catch (error) {
        console.error("Error extracting meaningful name from URL:", error);
      }
      if (meaningfulName) {
        meaningfulName = sanitizeFilename(meaningfulName);
        if (meaningfulName.length > 30) {
          meaningfulName = meaningfulName.substring(0, 30);
        }
        filename = `${meaningfulName}-${hash.substring(0, 8)}.${fileExtension}`;
      } else {
        filename = `${hash}.${fileExtension}`;
      }
    } else {
      const urlObj = new URL(imageUrl);
      const urlPath = urlObj.pathname;
      const originalFilename = path.basename(urlPath);
      filename = sanitizeFilename(originalFilename);
      if (!filename.includes(".")) {
        filename = `${filename}.${fileExtension}`;
      }
    }
    if (!filename.includes(".")) {
      filename = `${filename}.${fileExtension}`;
      console.log(`Added missing extension to filename: ${filename}`);
    }
    const localPath = `${settings.imageFolder}/${filename}`;
    if (await vault.adapter.exists(localPath)) {
      return { success: true, localPath };
    }
    await vault.createBinary(localPath, finalImageData);
    return { success: true, localPath };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error))
    };
  }
}
async function replaceAsync(str, regex, asyncFn) {
  const promises = [];
  str.replace(regex, (match, ...args) => {
    const promise = asyncFn(match, ...args);
    promises.push(promise);
    return match;
  });
  const data = await Promise.all(promises);
  return str.replace(regex, () => data.shift() || "");
}

// main.ts
var SaveImagesOfflinePlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SaveImagesOfflineSettingTab(this.app, this));
    this.addCommand({
      id: "save-images-offline-current-file",
      name: "Save images offline for current file",
      checkCallback: (checking) => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (activeView) {
          if (!checking) {
            this.processActiveFile();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "save-images-offline-all-files",
      name: "Save images offline for all files",
      callback: () => {
        this.processAllFiles();
      }
    });
    if (this.settings.autoDownloadImages) {
      this.registerEvent(
        this.app.vault.on("modify", (file) => {
          if (file instanceof import_obsidian3.TFile && file.extension === "md") {
            this.processFile(file, false);
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("create", (file) => {
          if (file instanceof import_obsidian3.TFile && file.extension === "md") {
            this.processFile(file, false);
          }
        })
      );
    }
    if (this.settings.downloadOnPaste) {
      this.registerEvent(
        this.app.workspace.on("editor-paste", this.handlePaste.bind(this))
      );
    }
    this.app.workspace.onLayoutReady(() => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (activeView && this.settings.autoDownloadImages) {
        if (activeView.file) {
          this.processFile(activeView.file, false);
        }
      }
    });
    const statusBarItem = this.addStatusBarItem();
    statusBarItem.setText("Save Images Offline");
    console.log("Save Images Offline plugin loaded");
  }
  onunload() {
    console.log("Save Images Offline plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Processes the currently active file
   */
  async processActiveFile() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      showNotice("No active markdown file");
      return;
    }
    if (activeView.file) {
      await this.processFile(activeView.file, true);
    } else {
      showNotice("No file is currently open");
    }
  }
  /**
   * Processes all markdown files in the vault
   */
  async processAllFiles() {
    const notice = new import_obsidian3.Notice("Processing all files...", 0);
    const files = this.app.vault.getMarkdownFiles();
    let processed = 0;
    let totalDownloaded = 0;
    let totalFailed = 0;
    for (const file of files) {
      const result = await this.processFile(file, false);
      processed++;
      if (result) {
        totalDownloaded += result.downloaded;
        totalFailed += result.failed;
      }
      if (processed % 10 === 0) {
        notice.setMessage(`Processing files: ${processed}/${files.length}`);
      }
    }
    notice.hide();
    showNotice(`Processed ${processed} files. Downloaded ${totalDownloaded} images. Failed: ${totalFailed}`);
  }
  /**
   * Processes a single markdown file
   * @param file The file to process
   * @param showNotification Whether to show a notification when done
   * @returns Stats about the processing
   */
  async processFile(file, showNotification = true) {
    if (!(file instanceof import_obsidian3.TFile) || file.extension !== "md") {
      return null;
    }
    try {
      const { content, stats } = await processMarkdownFile(
        file,
        this.app.vault,
        this.settings
      );
      if (stats.downloaded > 0) {
        await this.app.vault.modify(file, content);
        if (showNotification) {
          showNotice(
            `Downloaded ${stats.downloaded} images. Failed: ${stats.failed}. Skipped: ${stats.skipped}.`
          );
        }
      } else if (showNotification && stats.total > 0) {
        showNotice(
          `No new images downloaded. Failed: ${stats.failed}. Skipped: ${stats.skipped}.`
        );
      }
      return {
        downloaded: stats.downloaded,
        failed: stats.failed
      };
    } catch (error) {
      console.error(`Error processing file ${file.path}:`, error);
      if (showNotification) {
        showNotice(`Error processing file: ${error.message}`);
      }
      return null;
    }
  }
  /**
   * Handles paste events to process pasted content with images
   * @param evt The clipboard event
   * @param editor The editor instance
   * @param view The markdown view
   */
  async handlePaste(evt, editor, view) {
    if (!evt.clipboardData) {
      return;
    }
    if (evt.clipboardData.files.length > 0) {
      return;
    }
    const pastedText = evt.clipboardData.getData("text");
    const hasImageUrls = IMAGE_URL_REGEX.test(pastedText) || HTML_IMG_REGEX.test(pastedText);
    const isDirectImageUrl = pastedText.trim().startsWith("http") && isLikelyImageUrl(pastedText.trim());
    if (hasImageUrls || isDirectImageUrl) {
      evt.preventDefault();
      const stats = {
        total: 0,
        downloaded: 0,
        failed: 0,
        skipped: 0
      };
      let processedText;
      if (isDirectImageUrl && !hasImageUrls) {
        const wrappedText = `![image](${pastedText.trim()})`;
        processedText = await processContent(
          wrappedText,
          view.file || null,
          this.app.vault,
          this.settings,
          stats
        );
      } else {
        processedText = await processContent(
          pastedText,
          view.file || null,
          this.app.vault,
          this.settings,
          stats
        );
      }
      editor.replaceSelection(processedText);
      if (stats.total > 0) {
        showNotice(
          `Downloaded ${stats.downloaded} images. Failed: ${stats.failed}. Skipped: ${stats.skipped}.`
        );
      }
    }
  }
};
